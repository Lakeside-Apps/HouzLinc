/* Copyright 2022 Christian Fortini

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

using Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Insteon.Model;
using Insteon.Mock;
using Insteon.Base;

namespace UnitTests.Insteon;

public class ModelTestsBase
{
    private protected House house = null!;
    private protected House targetHouse = null!;

    public TestContext TestContext { get; set; } = null!;

    private protected async Task LoadModels(string filename)
    {
        // Load our working model that we will change directly
        var h = await ModelHolderForTest.LoadFromFile("Changes", filename);
        Assert.IsNotNull(h);
        house = h!;

        // set this to true to save the model if an update is needed
#if false
        await ModelHolderForTest.SaveToFile("Changes\\Models", filename, house);
#endif

        // Load model that we will change by playing the recorded changes against it
        var th = await ModelHolderForTest.LoadFromFile("Changes", filename);
        Assert.IsNotNull(th);
        targetHouse = th!;
    }

    private protected async Task PlayAndCheck()
    {
        // Play the changes recorded while modifying model house against yet unmodified targetHouse
        house.PlayModel(targetHouse);

        // Save the model that was modified directly
        // If this is different from the ref file stored in the ms-appx:///Refs folder,
        // investigate and either fix bug or update the ref file
        await ModelHolderForTest.SaveToFile("Changes\\Ref", TestContext.TestName!, house);

        // Save the model that was modified by playing the changes
        await ModelHolderForTest.SaveToFile("Changes", TestContext.TestName!, targetHouse);

        // Compare the file of the model generated by playing the changes with the ref file stored in the ms-appx:///Refs folder
        // Fail the test if they are different
        var result = await ModelHolderForTest.CompareFiles("Changes", TestContext.TestName!);
        Assert.IsNull(result, result);
    }

    private protected async Task PlayMergeAndCheck()
    {
        // Play the changes recorded while modifying model house locally
        // against targetHouse in which we simulated changes from another instance of this app
        // This gives us the merged model with all changes
        house.PlayModel(targetHouse);

        // Save the merged model
        // We can't use this as ref as it might be different than the ultimate working model
        // e.g., CopyFrom does not guarantee that the order of the devices will be kept the same
        await ModelHolderForTest.SaveToFile("Merges\\beforeCopy", TestContext.TestName!, targetHouse);

        // Now apply (copy) the merged model back on our working model (house)
        house.CopyFrom(targetHouse);

        // Save the new working model
        // If this is different from the ref file stored in the ms-appx:///Refs folder,
        // investigate and either fix bug or update the ref file
        await ModelHolderForTest.SaveToFile("Merges", TestContext.TestName!, house);

        // Compare the file of the working model with the ref file stored in the ms-appx:///Refs folder
        // Fail the test if they are different
        var result = await ModelHolderForTest.CompareFiles("Merges", TestContext.TestName!);
        Assert.IsNull(result, result);
    }
}

public static class HouseExtensions
{
    internal static async Task AddNewDevice(this House house, InsteonID newDeviceId, DeviceKind.CategoryId categoryId, int subCategory, int revision, Bits operatingFlags, string? name = null)
    {
        var allLinkDatabase = new AllLinkDatabase();
        allLinkDatabase.AddRecord(AllLinkRecord.CreateHighWaterMark());

        var mockPhysicalDevice = new MockPhysicalDevice(newDeviceId, allLinkDatabase)
        {
            CategoryId = categoryId,
            SubCategory = subCategory,
            ProductKey = 0,
            Revision = revision,
            OperatingFlags = operatingFlags
        };

        house.WithMockPhysicalDevice(new MockPhysicalIM(house.Hub!.Id, new AllLinkDatabase(house.Hub.AllLinkDatabase)))
             .WithMockPhysicalDevice(mockPhysicalDevice);

        await house.Devices.AddOrConnectDeviceAsync(newDeviceId);
        var device = house.Devices.GetDeviceByID(newDeviceId)!;
        if (name != null) device.DisplayName = name;
        await device.TryReadAllLinkDatabaseAsync();
        await house.Hub.TryReadAllLinkDatabaseAsync();
    }

    // Pretend to sync everything by changing statuses to "Synced"
    internal static void PretendSync(this House house)
    {
        foreach (var device in house.Devices)
        {
            device.PropertiesSyncStatus = SyncStatus.Synced;
            device.AllLinkDatabase.LastStatus = SyncStatus.Synced;
            for (int seq = 0; seq < device.AllLinkDatabase.Count; seq++)
            {
                device.AllLinkDatabase[seq] = new(device.AllLinkDatabase[seq]) { SyncStatus = SyncStatus.Synced };
            }
            foreach(var channel in device.Channels)
            {
                channel.PropertiesSyncStatus = SyncStatus.Synced;
            }
        }
    }
}
